aaload|50||arrayref, index → value|Load onto the stack a reference from an array
aastore|83||arrayref, index, value →|Store a reference in an array
aconst_null|1||→ null|Push a null reference onto the stack
aload|25|1: index|→ objectref|Load a reference onto the stack from a local variable #index
aload_0|42||→ objectref|Load a reference onto the stack from local variable 0
aload_1|43||→ objectref|Load a reference onto the stack from local variable 1
aload_2|44||→ objectref|Load a reference onto the stack from local variable 2
aload_3|45||→ objectref|Load a reference onto the stack from local variable 3
anewarray|189|2: indexbyte1, indexbyte2|count → arrayref|"Create a new array of references of length count and component type identified by the class reference index (indexbyte1 << 8 | indexbyte2) in the constant pool"
areturn|176||objectref → [empty]|Return a reference from a method
arraylength|190||arrayref → length|Get the length of an array
astore|58|1: index|objectref →|Store a reference into a local variable #index
astore_0|75||objectref →|Store a reference into local variable 0
astore_1|76||objectref →|Store a reference into local variable 1
astore_2|77||objectref →|Store a reference into local variable 2
astore_3|78||objectref →|Store a reference into local variable 3
athrow|191||objectref → [empty], objectref|Throws an error or exception (notice that the rest of the stack is cleared, leaving only a reference to the Throwable)
baload|51||arrayref, index → value|Load a byte or Boolean value from an array
bastore|84||arrayref, index, value →|Store a byte or Boolean value into an array
bipush|16|1: byte|→ value|Push a byte onto the stack as an integer value
breakpoint|202|||Reserved for breakpoints in Java debuggers; should not appear in any class file
caload|52||arrayref, index → value|Load a char from an array
castore|85||arrayref, index, value →|Store a char into an array
checkcast|192|2: indexbyte1, indexbyte2|objectref → objectref|"Checks whether an objectref is of a certain type, the class reference of which is in the constant pool at index (indexbyte1 << 8 | indexbyte2)"
d2f|144||value → result|Convert a double to a float
d2i|142||value → result|Convert a double to an int
d2l|143||value → result|Convert a double to a long
dadd|99||value1, value2 → result|Add two doubles
daload|49||arrayref, index → value|Load a double from an array
dastore|82||arrayref, index, value →|Store a double into an array
dcmpg|152||value1, value2 → result|Compare two doubles, 1 on NaN
dcmpl|151||value1, value2 → result|Compare two doubles, -1 on NaN
dconst_0|14||→ 0.0|Push the constant 0.0 (a double) onto the stack
dconst_1|15||→ 1.0|Push the constant 1.0 (a double) onto the stack
ddiv|111||value1, value2 → result|Divide two doubles
dload|24|1: index|→ value|Load a double value from a local variable #index
dload_0|38||→ value|Load a double from local variable 0
dload_1|39||→ value|Load a double from local variable 1
dload_2|40||→ value|Load a double from local variable 2
dload_3|41||→ value|Load a double from local variable 3
dmul|107||value1, value2 → result|Multiply two doubles
dneg|119||value → result|Negate a double
drem|115||value1, value2 → result|Get the remainder from a division between two doubles
dreturn|175||value → [empty]|Return a double from a method
dstore|57|1: index|value →|Store a double value into a local variable #index
dstore_0|71||value →|Store a double into local variable 0
dstore_1|72||value →|Store a double into local variable 1
dstore_2|73||value →|Store a double into local variable 2
dstore_3|74||value →|Store a double into local variable 3
dsub|103||value1, value2 → result|Subtract a double from another
dup|89||value → value, value|Duplicate the value on top of the stack
dup_x1|90||value2, value1 → value1, value2, value1|Insert a copy of the top value into the stack two values from the top. value1 and value2 must not be of the type double or long.
dup_x2|91||value3, value2, value1 → value1, value3, value2, value1|Insert a copy of the top value into the stack two (if value2 is double or long it takes up the entry of value3, too) or three values (if value2 is neither double nor long) from the top
dup2|92||{value2, value1} → {value2, value1}, {value2, value1}|Duplicate top two stack words (two values, if value1 is not double nor long; a single value, if value1 is double or long)
dup2_x1|93||value3, {value2, value1} → {value2, value1}, value3, {value2, value1}|Duplicate two words and insert beneath third word (see explanation above)
dup2_x2|94||{value4, value3}, {value2, value1} → {value2, value1}, {value4, value3}, {value2, value1}|Duplicate two words and insert beneath fourth word
f2d|141||value → result|Convert a float to a double
f2i|139||value → result|Convert a float to an int
f2l|140||value → result|Convert a float to a long
fadd|98||value1, value2 → result|Add two floats
faload|48||arrayref, index → value|Load a float from an array
fastore|81||arrayref, index, value →|Store a float in an array
fcmpg|150||value1, value2 → result|Compare two floats, 1 on NaN
fcmpl|149||value1, value2 → result|Compare two floats, -1 on NaN
fconst_0|11||→ 0.0f|Push 0.0f on the stack
fconst_1|12||→ 1.0f|Push 1.0f on the stack
fconst_2|13||→ 2.0f|Push 2.0f on the stack
fdiv|110||value1, value2 → result|Divide two floats
fload|23|1: index|→ value|Load a float value from a local variable #index
fload_0|34||→ value|Load a float value from local variable 0
fload_1|35||→ value|Load a float value from local variable 1
fload_2|36||→ value|Load a float value from local variable 2
fload_3|37||→ value|Load a float value from local variable 3
fmul|106||value1, value2 → result|Multiply two floats
fneg|118||value → result|Negate a float
frem|114||value1, value2 → result|Get the remainder from a division between two floats
freturn|174||value → [empty]|Return a float
fstore|56|1: index|value →|Store a float value into a local variable #index
fstore_0|67||value →|Store a float value into local variable 0
fstore_1|68||value →|Store a float value into local variable 1
fstore_2|69||value →|Store a float value into local variable 2
fstore_3|70||value →|Store a float value into local variable 3
fsub|102||value1, value2 → result|Subtract two floats
getfield|180|2: indexbyte1, indexbyte2|objectref → value|"Get a field value of an object objectref, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 | indexbyte2)"
getstatic|178|2: indexbyte1, indexbyte2|→ value|"Get a static field value of a class, where the field is identified by field reference in the constant pool index (indexbyte1 << 8 | indexbyte2)"
goto|167|2: branchbyte1, branchbyte2|[no change]|"Goes to another instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
goto_w|200|4: branchbyte1, branchbyte2, branchbyte3, branchbyte4|[no change]|"Goes to another instruction at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 | branchbyte2 << 16 | branchbyte3 << 8 | branchbyte4)"
i2b|145||value → result|Convert an int into a byte
i2c|146||value → result|Convert an int into a character
i2d|135||value → result|Convert an int into a double
i2f|134||value → result|Convert an int into a float
i2l|133||value → result|Convert an int into a long
i2s|147||value → result|Convert an int into a short
iadd|96||value1, value2 → result|Add two ints
iaload|46||arrayref, index → value|Load an int from an array
iand|126||value1, value2 → result|Perform a bitwise AND on two integers
iastore|79||arrayref, index, value →|Store an int into an array
iconst_m1|2||→ -1|Load the int value −1 onto the stack
iconst_0|3||→ 0|Load the int value 0 onto the stack
iconst_1|4||→ 1|Load the int value 1 onto the stack
iconst_2|5||→ 2|Load the int value 2 onto the stack
iconst_3|6||→ 3|Load the int value 3 onto the stack
iconst_4|7||→ 4|Load the int value 4 onto the stack
iconst_5|8||→ 5|Load the int value 5 onto the stack
idiv|108||value1, value2 → result|Divide two integers
if_acmpeq|165|2: branchbyte1, branchbyte2|value1, value2 →|"If references are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_acmpne|166|2: branchbyte1, branchbyte2|value1, value2 →|"If references are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_icmpeq|159|2: branchbyte1, branchbyte2|value1, value2 →|"If ints are equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_icmpge|162|2: branchbyte1, branchbyte2|value1, value2 →|"If value1 is greater than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_icmpgt|163|2: branchbyte1, branchbyte2|value1, value2 →|"If value1 is greater than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_icmple|164|2: branchbyte1, branchbyte2|value1, value2 →|"If value1 is less than or equal to value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_icmplt|161|2: branchbyte1, branchbyte2|value1, value2 →|"If value1 is less than value2, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
if_icmpne|160|2: branchbyte1, branchbyte2|value1, value2 →|"If ints are not equal, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifeq|153|2: branchbyte1, branchbyte2|value →|"If value is 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifge|156|2: branchbyte1, branchbyte2|value →|"If value is greater than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifgt|157|2: branchbyte1, branchbyte2|value →|"If value is greater than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifle|158|2: branchbyte1, branchbyte2|value →|"If value is less than or equal to 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
iflt|155|2: branchbyte1, branchbyte2|value →|"If value is less than 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifne|154|2: branchbyte1, branchbyte2|value →|"If value is not 0, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifnonnull|199|2: branchbyte1, branchbyte2|value →|"If value is not null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
ifnull|198|2: branchbyte1, branchbyte2|value →|"If value is null, branch to instruction at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2)"
iinc|132|2: index, const|[No change]|Increment local variable #index by signed byte const
iload|21|1: index|→ value|Load an int value from a local variable #index
iload_0|26||→ value|Load an int value from local variable 0
iload_1|27||→ value|Load an int value from local variable 1
iload_2|28||→ value|Load an int value from local variable 2
iload_3|29||→ value|Load an int value from local variable 3
impdep1|254|||Reserved for implementation-dependent operations within debuggers; should not appear in any class file
impdep2|255|||Reserved for implementation-dependent operations within debuggers; should not appear in any class file
imul|104||value1, value2 → result|Multiply two integers
ineg|116||value → result|Negate int
instanceof|193|2: indexbyte1, indexbyte2|objectref → result|"Determines if an object objectref is of a given type, identified by class reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
invokedynamic|186|4: indexbyte1, indexbyte2, 0, 0|[arg1, arg2, ...] → result|"Invokes a dynamic method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
invokeinterface|185|4: indexbyte1, indexbyte2, count, 0|objectref, [arg1, arg2, ...] → result|"Invokes an interface method on object objectref and puts the result on the stack (might be void); the interface method is identified by method reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
invokespecial|183|2: indexbyte1, indexbyte2|objectref, [arg1, arg2, ...] → result|"Invoke instance method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
invokestatic|184|2: indexbyte1, indexbyte2|[arg1, arg2, ...] → result|"Invoke a static method and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
invokevirtual|182|2: indexbyte1, indexbyte2|objectref, [arg1, arg2, ...] → result|"Invoke virtual method on object objectref and puts the result on the stack (might be void); the method is identified by method reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
ior|128||value1, value2 → result|Bitwise int OR
irem|112||value1, value2 → result|Logical int remainder
ireturn|172||value → [empty]|Return an integer from a method
ishl|120||value1, value2 → result|Int shift left
ishr|122||value1, value2 → result|Int arithmetic shift right
istore|54|1: index|value →|Store int value into variable #index
istore_0|59||value →|Store int value into variable 0
istore_1|60||value →|Store int value into variable 1
istore_2|61||value →|Store int value into variable 2
istore_3|62||value →|Store int value into variable 3
isub|100||value1, value2 → result|Int subtract
iushr|124||value1, value2 → result|Int logical shift right
ixor|130||value1, value2 → result|Int xor
jsr|168|2: branchbyte1, branchbyte2|→ address|"Jump to subroutine at branchoffset (signed short constructed from unsigned bytes branchbyte1 << 8 | branchbyte2) and place the return address on the stack"
jsr_w|201|4: branchbyte1, branchbyte2, branchbyte3, branchbyte4|→ address|"Jump to subroutine at branchoffset (signed int constructed from unsigned bytes branchbyte1 << 24 | branchbyte2 << 16 | branchbyte3 << 8 | branchbyte4) and place the return address on the stack"
l2d|138||value → result|Convert a long to a double
l2f|137||value → result|Convert a long to a float
l2i|136||value → result|Convert a long to a int
ladd|97||value1, value2 → result|Add two longs
laload|47||arrayref, index → value|Load a long from an array
land|127||value1, value2 → result|Bitwise AND of two longs
lastore|80||arrayref, index, value →|Store a long to an array
lcmp|148||value1, value2 → result|Push 0 if the two longs are the same, 1 if value1 is greater than value2, -1 otherwise
lconst_0|9||→ 0L|Push 0L (the number zero with type long) onto the stack
lconst_1|10||→ 1L|Push 1L (the number one with type long) onto the stack
ldc|18|1: index|→ value|Push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) onto the stack
ldc_w|19|2: indexbyte1, indexbyte2|→ value|"Push a constant #index from a constant pool (String, int, float, Class, java.lang.invoke.MethodType, java.lang.invoke.MethodHandle, or a dynamically-computed constant) onto the stack (wide index is constructed as indexbyte1 << 8 | indexbyte2)"
ldc2_w|20|2: indexbyte1, indexbyte2|→ value|"Push a constant #index from a constant pool (double, long, or a dynamically-computed constant) onto the stack (wide index is constructed as indexbyte1 << 8 | indexbyte2)"
ldiv|109||value1, value2 → result|Divide two longs
lload|22|1: index|→ value|Load a long value from a local variable #index
lload_0|30||→ value|Load a long value from a local variable 0
lload_1|31||→ value|Load a long value from a local variable 1
lload_2|32||→ value|Load a long value from a local variable 2
lload_3|33||→ value|Load a long value from a local variable 3
lmul|105||value1, value2 → result|Multiply two longs
lneg|117||value → result|Negate a long
lookupswitch|171|8+: <0–3 bytes padding>, defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, npairs1, npairs2, npairs3, npairs4, match-offset pairs...|key →|A target address is looked up from a table using a key and execution continues from the instruction at that address
lor|129||value1, value2 → result|Bitwise OR of two longs
lrem|113||value1, value2 → result|Remainder of division of two longs
lreturn|173||value → [empty]|Return a long value
lshl|121||value1, value2 → result|Bitwise shift left of a long value1 by int value2 positions
lshr|123||value1, value2 → result|Bitwise shift right of a long value1 by int value2 positions
lstore|55|1: index|value →|Store a long value in a local variable #index
lstore_0|63||value →|Store a long value in a local variable 0
lstore_1|64||value →|Store a long value in a local variable 1
lstore_2|65||value →|Store a long value in a local variable 2
lstore_3|66||value →|Store a long value in a local variable 3
lsub|101||value1, value2 → result|Subtract two longs
lushr|125||value1, value2 → result|Bitwise shift right of a long value1 by int value2 positions, unsigned
lxor|131||value1, value2 → result|Bitwise XOR of two longs
monitorenter|194||objectref →|"Enter monitor for object (\""grab the lock\"" – start of synchronized() section)"""
monitorexit|195||objectref →|"Exit monitor for object exit monitor for object (\""release the lock\"" – end of synchronized() section)"
multianewarray|197|3: indexbyte1, indexbyte2, dimensions|count1, [count2, ...] → arrayref|"Create a new array of dimensions dimensions of type identified by class reference in constant pool index (indexbyte1 << 8 | indexbyte2); the sizes of each dimension is identified by count1, [count2, etc.]"
new|187|2: indexbyte1, indexbyte2|→ objectref|"Create new object of type identified by class reference in constant pool index (indexbyte1 << 8 | indexbyte2)"
newarray|188|1: atype|count → arrayref|Create new array with count elements of primitive type identified by atype
nop|0||[No change]|Perform no operation
pop|87||value →|Discard the top value on the stack
pop2|88||{value2, value1} →|Discard the top two values on the stack (or one value, if it is a double or long)
putfield|181|2: indexbyte1, indexbyte2|objectref, value →|"Set field to value in an object objectref, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
putstatic|179|2: indexbyte1, indexbyte2|value →|"Set static field to value in a class, where the field is identified by a field reference index in constant pool (indexbyte1 << 8 | indexbyte2)"
ret|169|1: index|[No change]|Continue execution from address taken from a local variable #index (the asymmetry with jsr is intentional)
return|177||→ [empty]|Return void from method
saload|53||arrayref, index → value|Load short from array
sastore|86||arrayref, index, value →|Store short to array
sipush|17|2: byte1, byte2|→ value|Push a short onto the stack as an integer value
swap|95||value2, value1 → value1, value2|Swaps two top words on the stack (note that value1 and value2 must not be double or long)
tableswitch|170|16+: [0–3 bytes padding], defaultbyte1, defaultbyte2, defaultbyte3, defaultbyte4, lowbyte1, lowbyte2, lowbyte3, lowbyte4, highbyte1, highbyte2, highbyte3, highbyte4, jump offsets...|index →|Continue execution from an address in the table at offset index
wide|196|3/5: opcode, indexbyte1, indexbyte2 or iinc, indexbyte1, indexbyte2, countbyte1, countbyte2|[same as for corresponding instructions]|Execute opcode, where opcode is either iload, fload, aload, lload, dload, istore, fstore, astore, lstore, dstore, or ret, but assume the index is 16 bit; or execute iinc, where the index is 16 bits and the constant to increment by is a signed 16 bit short
